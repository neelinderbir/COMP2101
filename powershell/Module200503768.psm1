#
# Module manifest for module 'Module200503768'
#
# Generated by: dell
#
# Generated on: 2023-04-02
#

@{

# Script module or binary module file associated with this manifest.
# RootModule = ''

# Version number of this module.
ModuleVersion = '1.0'

# Supported PSEditions
# CompatiblePSEditions = @()

# ID used to uniquely identify this module
GUID = '7d72b095-0575-4fd3-9cea-da1a22c4ad54'

# Author of this module
Author = 'dell'

# Company or vendor of this module
CompanyName = 'Unknown'

# Copyright statement for this module
Copyright = '(c) 2023 dell. All rights reserved.'

# Description of the functionality provided by this module
# Description = ''

# Minimum version of the Windows PowerShell engine required by this module
# PowerShellVersion = ''

# Name of the Windows PowerShell host required by this module
# PowerShellHostName = ''

# Minimum version of the Windows PowerShell host required by this module
# PowerShellHostVersion = ''

# Minimum version of Microsoft .NET Framework required by this module. This prerequisite is valid for the PowerShell Desktop edition only.
# DotNetFrameworkVersion = ''

# Minimum version of the common language runtime (CLR) required by this module. This prerequisite is valid for the PowerShell Desktop edition only.
# CLRVersion = ''

# Processor architecture (None, X86, Amd64) required by this module
# ProcessorArchitecture = ''

# Modules that must be imported into the global environment prior to importing this module
# RequiredModules = @()

# Assemblies that must be loaded prior to importing this module
# RequiredAssemblies = @()

# Script files (.ps1) that are run in the caller's environment prior to importing this module.
# ScriptsToProcess = @()

# Type files (.ps1xml) to be loaded when importing this module
# TypesToProcess = @()

# Format files (.ps1xml) to be loaded when importing this module
# FormatsToProcess = @()

# Modules to import as nested modules of the module specified in RootModule/ModuleToProcess
# NestedModules = @()

# Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.
FunctionsToExport = @()

# Cmdlets to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no cmdlets to export.
CmdletsToExport = @()

# Variables to export from this module
VariablesToExport = '*'

# Aliases to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no aliases to export.
AliasesToExport = @()

# DSC resources to export from this module
# DscResourcesToExport = @()

# List of all modules packaged with this module
# ModuleList = @()

# List of all files packaged with this module
# FileList = @()

# Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.
PrivateData = @{

    PSData = @{

        # Tags applied to this module. These help with module discovery in online galleries.
        # Tags = @()

        # A URL to the license for this module.
        # LicenseUri = ''

        # A URL to the main website for this project.
        # ProjectUri = ''

        # A URL to an icon representing this module.
        # IconUri = ''

        # ReleaseNotes of this module
        # ReleaseNotes = ''

    } # End of PSData hashtable

} # End of PrivateData hashtable

# HelpInfo URI of this module
# HelpInfoURI = ''

# Default prefix for commands exported from this module. Override the default prefix using Import-Module -Prefix.
# DefaultCommandPrefix = ''

}

$env:path += ";$home/documents/github/comp2101/powershell"

function welcome{
write-output "Welcome to planet $env:computername Overlord $env:username"
$now = get-date -format 'HH:MM tt on dddd'
write-output "It is $now."
}

function get-cpuinfo{
$cpuInfo = Get-CimInstance CIM_Processor | Select-Object Manufacturer, Name, MaxClockSpeed, CurrentClockSpeed, NumberOfCores
$cpuInfo | format-table 
}

function get-mydisks {
$diskinfo =Get-CimInstance CIM_DiskDrive | ForEach-Object {
        [PSCustomObject]@{
            Manufacturer= $_.Manufacturer
            Model= $_.Model
            SerialNumber= $_.SerialNumber
            FirmwareRevision = $_.FirmwareRevision
            Size= $_.Size
        }
    }     
$diskinfo | format-table -autosize
}


function ipconfig-info{
# I am storing the filtered output in a variable  named adatpterobj.
$adapterobjs = Get-CimInstance Win32_NetworkAdapterConfiguration | Where-Object {$_.IPEnabled}

# i have used Write-Output for formatting the report.
Write-Output "      "
Write-Output "============================================================================================"
Write-Output "IP Configuration Report"
Write-Output "============================================================================================"
Write-Output "      "

# this foreach loop i have created to extract the details for each of the adapter which is then stored in variable named report.
$report = foreach ($adapterobj in $adapterobjs) {
    [PSCustomObject]@{
        "Adapter Description" = $adapterobj.Description
        "Index" = $adapterobj.Index
        "IP Address" = $adapterobj.IPAddress
        "Subnet Mask" = $adapterobj.IPSubnet
        "DNS Domain Name" = $adapterobj.DNSDomain
        "DNS Server" = $adapterobj.DNSServerSearchOrder
#     "MAC Address " = $adapterobj.MACAddress
    }
} $report 

}

#to formate table i have pass it directly to variable where the data output is stored.
$report | Format-Table -AutoSize

# This Function  will retrive the system hardware.
function Detail-Sys-Hardware{
    $systemDetail = Get-WmiObject -Class Win32_ComputerSystem
    $output = @()
    $output += "Hardware Manufacturer: $($systemDetail.Manufacturer)"
    $output += "Hardware Model: $($systemDetail.Model)"
    $output += "Total Physical Memory: $([math]::Round($systemDetail.TotalPhysicalMemory / 1GB, 2)) GB"
    $output += "Hardware Description: $($systemDetail.Description)"
    $output += "System Type: $($systemDetail.SystemType)"
    return $output

}

# This Function  will retrive the operating system detail.
Function Detail-OperatingSystem {
    $osDetail = Get-WmiObject -Class Win32_OperatingSystem
    $output = @()
    $output += "System Name: $($osDetail.Caption)"
    $output += "Version Number: $($osDetail.Version)"
    return $output
}

# This Function  will retrive the Detail processor.
Function Detail-processor {
    $processor = Get-WmiObject -Class Win32_Processor
    $output = @()
    $output += "Name: $($processor.Name)"
    $output += "Number of Cores: $($processor.NumberOfCores)"
    $output += "Speed: $($processor.MaxClockSpeed) MHz"
    if ($processor.L1CacheSize -ne $null) {
        $output += "L1 Cache Size: $($processor.L1CacheSize / 1KB) KB"
    } else {
        $output += "L1 Cache Size: N/A"
    }
    if ($processor.L2CacheSize -ne $null) {
        $output += "L2 Cache Size: $($processor.L2CacheSize / 1KB) KB"
    } else {
        $output += "L2 Cache Size: N/A"
    }
    if ($processor.L3CacheSize -ne $null) {
        $output += "L3 Cache Size: $($processor.L3CacheSize / 1KB) KB"
    } else {
        $output += "L3 Cache Size: N/A"
    }
    return $output
}

# This Function  will retrive the Ram memory.
Function Detail-RAM-Memory {
   $memory = Get-WmiObject -Class Win32_PhysicalMemory
    $totalMemory = 0
    $output = @()
    
    foreach ($mem in $memory) {
        $output += [PSCustomObject]@{
            Vendor = $mem.Manufacturer
            Description = $mem.Description
            Capacity = "{0:N2} GB" -f ($mem.Capacity / 1GB)
            "Bank/Slot" = $mem.DeviceLocator
            "Memory Type" = $mem.MemoryType
            Speed = $mem.Speed
        }
          $totalMemory += $mem.Capacity
    }
    
    $output | Format-Table -AutoSize
    Write-Host "Total RAM installed: $(('{0:N2}' -f ($totalMemory / 1GB))) GB"

 }

# This Function  will retrive the Disk drive.
function Detail-DiskDrive{
 $diskdrives = Get-CIMInstance CIM_diskdrive

  foreach ($disk in $diskdrives) {
      $partitions = $disk|get-cimassociatedinstance -resultclassname CIM_diskpartition
      foreach ($partition in $partitions) {
            $logicaldisks = $partition | get-cimassociatedinstance -resultclassname CIM_logicaldisk
            foreach ($logicaldisk in $logicaldisks) {
	$freeSpace = [math]::Round(($logicaldisk.FreeSpace / $logicaldisk.Size) * 100, 2)

#new-object -typename psobject -property 
		$drive = [PSCustomObject]@{

			Manufacturer=$disk.Manufacturer
                                                          Model=$disk.Model     
			 Size = "{0:N2} GB" -f ($logicaldisk.Size / 1GB)
               			  "Free Space" = "{0:N2} GB" -f ($logicaldisk.FreeSpace / 1GB)
			"Free space in %" = "$freeSpace%"
                                                     }
		 $drive 
           }
      }
  }

}
                                                         
# This Function  will retrive the video Controller.
Function Detail-VideoController {
    $video = Get-WmiObject -Class Win32_VideoController
    $output= foreach ($v in $video) {
        [PSCustomObject]@{
            Vendor = $v.VideoProcessor
            Description = $v.Description
            Resolution = "{0}x{1}" -f $v.CurrentHorizontalResolution, $v.CurrentVerticalResolution
        }
    }
    $output
}


# I have used Write-Output for formatting the report.
#fortting the output for system hardware detail
Write-Output "      "
Write-Output "      "
Write-Output "					System Information Report"
Write-Output "      "
Write-Output "============================================================================================"
Write-Output "Hardware Detail"
Write-Output "============================================================================================"
# to call the system hardware function.
Detail-Sys-Hardware
Write-Output "      "

#operating system detail
Write-Output "============================================================================================"
Write-Output "Operating System Detail"
Write-Output "============================================================================================"
# to call the system hardware function.
Detail-OperatingSystem
Write-Output "      "


# To print output for processor
Write-Output "============================================================================================"
Write-Output "Processor Detail"
Write-Output "============================================================================================"
# to call the system hardware function.
Detail-processor
Write-Output "      "

#to print output for Memory
Write-Output "============================================================================================"
Write-Output "RAM Detail"
Write-Output "============================================================================================"
# to call the system hardware function.
Detail-RAM-Memory
Write-Output "      "

#to print output for Disk
Write-Output "============================================================================================"
Write-Output "Disk Detail"
Write-Output "============================================================================================"
Detail-DiskDrive | Format-Table -AutoSize
Write-Output "      "

# I am calling the Network adapter Configuration
#ipconfig-info.ps1
$report

# I am calling the video Controller
Write-Output "============================================================================================"
Write-Output "Video Controller Detail"
Write-Output "============================================================================================"
Detail-VideoController | Format-List


